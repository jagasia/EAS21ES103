
Trainer
	Jagadeeswaran Rangappan


Session begins at 9:00 am
Break	at 11:00 am		
Lunch break at 1:00 pm	to 2:00 pm
Break at 4:00 pm



RDBMS & SQL
	usually, our java batches have MySql
	very rarely, batches learn Oracle sql and plsql

SalesForce is the domain

java is the technology

----------------------------------------------
RDBMS
-----
	Database Management Systems

		Relational Algebra	
			Dr. E.F. Codd
		12 rules. if we follow that then we can create a RDBMS

wHAT is the RDBMS?
	Relational Database Management System

If you see accounts book, ledger
	any form of information system was maintained in the form of TABLE

	Tabular format.		
what is tabular format?
	row column format

	this row column format is called as Relation

A query returns a portion of the table.
	that result is a relation. But not a table.

A table is an example for relation (because, table is also row column format)

Relation is clear now.

What is Relationship?
----------------------

entity
	becomes table in the database
	becomes class in java program


Relations have relationship

Friends have friendship

table is an example for relation.
	then between tables, relationship can exist


in Relational algebra, Dr. Codd has given few terms	(Terminology)

Relation
Relationship
Table
Row	/	Record		/	Tuple
Column	/	Field		/	Attribute
Data
Cell		intersection of row and column
Entity
NULL			means 	nothing		NOT EVEN A SPACE OR ZERO	missing info
Operators
	UNION
		combines records from 2 queries
			if first query returns 5 records
			if second query returns 5 records
		then obviously we expect (5+5) 10 records. But if any records are exactly same found in both then, duplicates are eliminated
			5+5 may not be exactly 10. it may be <=10
	UNION ALL
		if first query returns 5 records and second query returns 5 records
		then the result will be definitely 5+5 ie., 10 records 	(including duplicates)
	INTERSECT
		is nothing but the common data found in both relation
	MINUS
		first minus second.		All from first query, minus the common element
	DIVIDE
		there are 5 customers.	(5 rows in customer table)
		there 10 products.	(10 rows in product table)
		display all customers who have purchased all products
		ie., in SALES table, if a customer found to have records for all products
		
JOIN
PRODUCT
CARTESIAN PRODUCT




1 1 1 1 1 
1 1 1 

6/2

1 1 1 1 1 1 
1 1

	3

3 rows in table 1
3 rows in table 2

so totally 3 * 3 = 9 combinations i can get. This is product
	what happens if all 3 customers buy all three products? 
		it will be 9 transactions


------------------------------------------------------------
Database Designing:
-------------------
	I am going to finally arrive at the database diagram.
	Tables and columns in each table

	how many tables should be created?
	What are those tables?
	in each table, what are the columns to be present?


Main purpose of a project is to maintain information.

data entered using
	textbox
	it allowed selecting from given options
	date can be chosen from calender
	your current location is an input		(Ola, Uber)
		based on that input, a suitable cab will be allocated



Database designing is done scientifically using 
	Normalization

-----------------------------------------
Normalization is a scientific approach, step by step activity to arrive at the best choice of tables and columns
Normalization aims to reduce the redundancy of data
	What is redundancy?
		is unnecessary repeatation of data in multiple locations
	ex:
		"ATTENDANCE" table
		Date 	AssociateId 	AssociateName	Phone	Email	Status
		-----------------------------------------------------------------

	WHat is the problem?
		every day we mark attendance.
		so every date, the associate name, phone, email is repeated unnecessarily.
		also some day, their phone and email might be entered differently causing inconsistency
		Name itself
			Jagadeeswaran R
			R. Jagadeeswaran
			Jagadees waran R
			Jagadeeswaran. R
		Look at the inconsistencies in the name itself

		DATE ASSOCIATEID STATUS
		--------------------------

		Look at the above table having only 3 columns.
		TO maintain name, phone, email, we can create ASSOCIATE TABLE
		ASSOCIATE table
			ASSOCIATEID	NAME	PHONE	EMAIL
			----------------------------------------
		Here, name, phone and email for every associate is found only once. Not for every day they attend


	by splitting a large table into small tables, we improve consistency and reduce redundancy.

This normalization is achieved in multiple steps:
	1NF
	2NF
	3NF
	BCNF

A table is said to be in 1st Normal Form if every cell in the table has precisely only 1 data.
	ex:
		NAME			ADDRESS
		-----			-------
		Rama Krishna		Shanti Apartments, Chennai - 600002 Tamil Nadu
		Suresh Krishna		Abcd colony, Bengaluru - 550001 Karnataka

Now, if you see this table having 2 columns
	information search is difficult to find by city or find by state or find by apartment name etc

	i need to find all customers from chennai?
	i need to find all customers whose name is Krishna?

	to simplify,

	FIRSTNAME 	LASTNAME		ADDRESS		CITY		PINCODE		STATE
	----------------------------------------------------------------------------------------------
	RAMA		KRISHNA		SHANTI APT		CHENNAI		600002		TAMIL NADU
	SURESH		KRISHNA		ABCD COLONY		BENGALURU	550001		KARNATAKA


	SELECT * FROM CUSTOMER WHERE LASTNAME='KRISHNA';		--very simple


There comes a concept called "Functional Dependency"
	a column is dependent on another column
		ex:		state may be dependent on pincode or city.

if you take ATTENDANCE table
		DATE, ASSOCIATEID, NAME, PHONE, EMAIL

	for attendance, why should the phone and email be recorded?????

	here functional dependency in 2nd Normal form advice us to RETAIN only columns dependent on the whole key.

	whole key is ATTENDANCE. For functionality of attendance, 
		DATE	associateid STATUS
	are only enough

	remaining values should be formed as a table
		PHONE, EMAIL are dependent on the ASSOCIATE

	ASSOCIATE
	----------
	ASSOCIATEID	NAME	PHONE EMAIL	ADDRESS 	CITY	PINCODE 	STATE

Suppose, if ASSOCIATE table had, address, phone, email,
	then we in 2nd Normal form, we are ok to have them also. Though they are dependent on the whole key. Means,
	they are informed by the associate. They are related to the customer. 2NF they are fine

But to be in 3NF, the address, is ok. But pin code and state are not dependent on the PRIMARY KEY ie., ASSOCIATE ID
	so they are split now

	CITYMASTER
	CITYID		CITY	PINCODE		STATE

	Now, the ASSOCIATE TABLE WILL CONTAIN ONLY CITYID
		REMAINING INFO we can refer to city master table


1 NF		-	Each cell in the table has precisely only 1 data
2 NF		-	Each column in the table is functionally dependant on the whole table
3 NF		-	Each column in the table is functionally dependent on the PRIMARY KEY of the table
BCNF		-	Boyce-Codd are 2 scientists. They call a table is in BCNF if the table has more than 1 determinant. Means, candidate key.
			They are overlapping. 

Candidate Key
	is any column or columns that is/are used to identify a row in the table uniquely.

It is a candidate for primary key.


Candidate Key
Primary Key
Alternate Key
Foreign Key
Unique Key
Composite Key
Super Key

There is a portal where we can practise SQL language free of cost. 
More importantly, it has sample tables and lot of records.

livesql.oracle.com
	signup for free



usually in databases,
	why table name and column names are in _ format
		FIRST_NAME
		LAST_NAME
		PHONE_NUMBER

	Look at this _ underscore


	Because, usually, in Database tables, we follow UPPERCASE convention.

in Java:
	FirstName
	LastName
	PhoneNumber

this is the format we use in Java:
	the same fields in database when they are in upper case, the readability is difficult
	FIRSTNAME		it does not look like 2 words. so it is changed into:
	FIRST_NAME

So for every capital is changed like	N	=	_N		
	MANAGER_ID		in java it will be ManagerId		I	=	_I				


------------------------------
Lets learn few SQL commands now:
SQL stands for "Structured Query Language"
	in sql there are many languages
		DML	-	Data Manipulation Language
		DDL	-	Data Definition Language
		DQL	-	Data Query Language
		DCL	-	Data Control Language
		TCL	-	Transaction Control Language

DML:
----
	INSERT
	UPDATE
	DELETE
	MERGE		(in oracle)
DDL:
----
	CREATE
	ALTER
	DROP
	TRUNCATE
DQL:
-----
	SELECT
DCL:
-----
	GRANT
	REVOKE
TCL:
-----
	COMMIT
	ROLLBACK
	SAVEPOINT




---------------------------------
SELECT:
	WHERE condition
	ORDER BY
	GROUP BY
	HAVING
	JOIN
	SUB QUERY
	OPERATORS
		LIKE
		NOT LIKE
		BETWEEN
		NOT BETWEEN
		=
		!=			<>
		IN
		NOT IN
		>
		<
		>=
		<=
		AND
		OR
		NOT
		ANY			/	SOME
		ALL
	FUNCTIONS
		AGGREGATE FUNCTIONS
			SUM
			MIN
			MAX
			COUNT
			AVG
		SINGLE ROW FUNCTIONS
			UPPER
			LOWER
			SUBSTRING
			COALESCE
			NULLIF
			NVL
			NVL2
			DECODE
			


-----------------------
What is the main aim of select query?
	to get / to retrieve data from a table or tables

	can we get all rows from a table?
		yes!		SELECT * FROM TABLE			* means, all columns. 
		since there is no condition given "where" then all rows are displayed


in live sql portal,
	lets go to sql worksheet

There is a table called EMPLOYESS but it is inside a schema called "HR"
	select * from hr.employees
	SELECT * FROM HR.EMPLOYEES

	I am getting 107 records for the above query.
	to run a query, i used "Ctrl+Enter"		or click "Run" button on right top


These are the columns found:
EMPLOYEE_ID	FIRST_NAME	LAST_NAME	EMAIL	PHONE_NUMBER	HIRE_DATE	JOB_ID	SALARY	COMMISSION_PCT	MANAGER_ID	DEPARTMENT_ID

I do not want to see all the columns.
To show only EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY

i will modify the query. 
	Instead of *
i will use exact column names in the query
	SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY FROM EMPLOYEES;


first, we displayed all columns.
now we display only 4 columns.
	THIS IS CALLED AS "PROJECTION"
			   ------------

in RDBMS, what is Projection?
	projecting only few attributes of the entity is called as "Projection"

in select query, what is projection?
	only few columns. 
	only columns of choice.
	only specific columns
	instead of using * in select query, we use specific column names


What is SELECTION?
	----------
There are 107 records found in EMPLOYEES table.
	Instead of showing all the records, i want to show only few records.

in interviews,
	there are 100 Applicants.
	so there are 100 rows found in the APPLICANTS table.
	but whoever scores >80 marks should be displayed.

	

SELECT EMPLOYEE_ID, FIRST_NAME, UPPER(FIRST_NAME), LAST_NAME, SALARY 
FROM HR.EMPLOYEES
WHERE salary>10000;

Here, we are not getting all 107 rows from EMPLOYEES table.
We are getting only 15 rows.
THis IS SELECTION
	-----------


Now you understand what is :
PROJECTION
SELECTION

==============================================POST LUNCH===========================
Now a days, Oracle corporation owns MySql also and Oracle of course.

There are lot of RDBMS products available in the market.
Oracle is the leader in the RDBMS industry
	in terms of security, capacity, availability, robustness


Oracle offeres
	free version of Database product called "Express Edition"
	commercial version, that we have to purchase is "Enterprise Edition"


sys
system
hr
	these are some of the users automatically created while installing Oracle in our computer
	while installation, it will ask you to set the passwords for sys and system.

	You will assign the role of "sys" to someone. "system" to someone.

	If sys forgots the password, then system can change the password of sys without even knowing old password.


	"sys" or "system" are the administrators, commonly called as "DBA". The dba can change the password of any user in oracle.

Oracle
MS SQL Server
IBM DB2


We have downloaded oracle 11 g and installed it 
in desktop you can see "Get Started With Oracle Database 11g Express Edition"

XE would be icon

During installation, we have set the password for "SYS" and "SYSTEM" accounts:
	password

There are 2 ways to login to oracle  (at this moment)
	1) in destop, find the icon "XE" 	Get Started With Oracle Database 11g Express Edition 
	2) in start menu, type run sql command line


in start menu:
	run sql command line
		connect sys as sysdba
		password


After you logged into the command line sql:
	1) unlock the account "HR"
		there is an account called "hr". which is locked once installation is completed.
		a DBA like SYS	can unlock this user. ANd also set password for this user.

		i am going to unlock "hr" now:
			ALTER USER hr ACCOUNT unlock;

		I AM going to change the password of "hr" to "hr":
			ALTER USER hr IDENTIFIED BY hr;


Lets learn to use APEX		(Application Express)
for that, in desktop, double click the XE (Get Started With Oracle Database 11g Express Edition )



While opening that "Get Started", if error comes,
	go to 
		http://127.0.0.1:8080/apex/f?p=4950
	directly in a browser. If that works,
	right click the desktop icon and go to the file location.
	right click the icon and set URL as 
		http://127.0.0.1:8080/apex/f?p=4950

Now, once "APEX" has opened, click "Application Express"
	Login as a database user which has been granted the DBA database role 

		sys
		password
	now we have logged in as dba.


	
Single row function:
	SELECT upper(first_name) FROM EMPLOYEES;	--returns 1 result per row 	(every row)

Aggregate function:
	SELECT SUM(SALARY) FROM EMPLOYEES;		--returns only 1 result per table/ group




Single Row Functions:
	numeric
	character
	date
	conversion
	miscellaneous



where  can we use single row functions?
	SELECT UPPER(FIRST_NAME) FROM EMPLOYEES;
here, we used it in select clause
	SELECT * FROM EMPLOYEES WHERE UPPER(FIRST_NAME)='STEVEN';
here, we use it in where clause

similarly we can use it in ORDER BY also
	SELECT FIRST_NAME FROM EMPLOYEES ORDER BY LENGTH(FIRST_NAME);
here, we use it in order by clause


select 1.2356, round(1.2356,2) from dual;			//1.24
select 1.2356, trunc(1.2356,2) from dual;			//1.23

ROUND		round to specific digits 		based on 5 or more becomes next value
TRUNC		just cut the specific digits		not based on 5 or more
MOD		divide and return the reminder
			
		there are 55 elements in an array
			0 to 54

		any number MOD 55		will return between 0 and 54 only

		lets take example of smaller range

anything mod 4 returns 0-3 only

40 mod 4		is 0
17 mod 4		is 1
26 mod 4		is 2
3 mod 4			is 3
4 mod 4			is 0



SELECT MONTHS_BETWEEN(SYSDATE, '01-JAN-21') FROM DUAL;
	this is correct in oracle.

ONLY IN APEX:
	SELECT MONTHS_BETWEEN(SYSDATE, '01/01/2021') FROM DUAL;




dd-MMM-yy				in all other oracle queries
MM/dd/yyyy				only in apex editor

select employee_id, first_name, add_months(hire_date, 240) from employees;


CONVERSION FUNCTIONS:
--------------------
	TO_NUMBER
	TO_CHAR
	TO_DATE


Implicit conversion happens when:
	we provide char data to date
		'01-Mar-2021'			this is a char data but is implicitly converted into date because the 							date format is correct
	'2021-03-01'		THIS WILL NOT BE IMPLICITLY CONVERTED INTO DATE
		SELECT TO_DATE('2021-03-01','yyyy-MM-dd') from dual;



Assignment:
-----------
1) single row functions
	numeric
	char
	date
	conversion
	miscellaneous
---------------------------------------------
Clauses in SQL
	Group By Clause
	Having Clause
	Order By Clause
	Order of Execution of Clauses in SELECT Statement



What is the use of Group By clause in SELECT Query?
	
Whenever we use aggregate functions, we get 1 result per table/ relation


SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMPLOYEES;
	we got 107 rows as result

SELECT SUM(SALARY) FROM EMPLOYEES;
	we got only 1 row as a result


SELECT DEPARTMENT_ID, SUM(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT DEPARTMENT_ID, COUNT(EMPLOYEE_ID), SUM(SALARY), AVG(SALARY) FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT job_id, SUM(SALARY) FROM EMPLOYEES
group by job_id;



What is the use of Having?
	WHERE condition restricts the rows.
	HAVING condition restricts the groups.
	
	WHERE condition cannot have aggregate functions in condition
		ex:		WHERE SUM(SALARY)>10000		--is not possible
	but
		ex:		HAVING SUM(SALARY)>10000	--is possible


SELECT job_id, SUM(SALARY) FROM EMPLOYEES
group by job_id
having sum(salary)>30000;


-------------------------
What is the use of ORDER BY clause?

SELECT job_id, SUM(SALARY) FROM EMPLOYEES
group by job_id
having sum(salary)>30000
ORDER BY sum(salary) desc;

SELECT job_id, SUM(SALARY) FROM EMPLOYEES
group by job_id
having sum(salary)>30000
ORDER BY sum(salary) asc;


asc is not mandatory. by default it is asc only

sorting works for character, date, numeric columns also


SELECT FIRST_NAME FROM EMPLOYEES ORDER BY FIRST_NAME DESC;


ORDER BY must be the last statement in SELECT query


SELECT SUM(SALARY) FROM EMPLOYEES
where employee_id<120
group by job_id
having sum(salary)>20000
;


where condition before group by.


1) result is obtained based on column list and where conditions
2) grouping
3) group condition in "having"
4) order by

=============================================
Why do we need joins?
	Whenever we need to retrieve data from more than 1 table, JOIN is required


SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
ORDER BY E.EMPLOYEE_ID;


SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID=D.DEPARTMENT_ID
ORDER BY E.EMPLOYEE_ID;


inner join produces only matching rows.
	So Kimberely Grant whose, department id is null, do not have matching department id in departments table.
	So his record is not found in the previous query.

so we need to get all the rows from employees table, including "kimberely grant" record

SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID=D.DEPARTMENT_ID(+)
ORDER BY E.EMPLOYEE_ID;

the above query is a theta join where left outer join is implemented.
what is a left outer join?
	all records from the left side table, and the matching records from right side table. if no matching found in 		right side table, then null is displayed

tHE same can be done using JOIN syntax as:

SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
ORDER BY E.EMPLOYEE_ID;





Now, we do not find some department ids in the above query. WHY?
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
ORDER BY E.department_ID;



SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E FULL OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
ORDER BY E.department_ID;



CROSS JOIN
	is a cartesian product of both tables
SELF JOIN
NATURAL JOIN
	occurs when there is a common column. means, column names are same
SELECT * FROM EMPLOYEES JOIN DEPARTMENTS
USING (DEPARTMENT_ID);

NON EQUI JOIN
	
SELECT FIRST_NAME, LAST_NAME, SALARY, J.JOB_TITLE
 FROM EMPLOYEES E JOIN JOBS J 
 ON E.SALARY BETWEEN J.MIN_SALARY AND J.MAX_SALARY
 ORDER BY EMPLOYEE_ID;



SELF JOIN
---------
select e.employee_id, e.first_name, e.last_name, e.salary, e.manager_id,
m.first_name || ' ' || m.last_name "Manager"
from employees e join employees m
on e.manager_id=m.employee_id
order by e.employee_id;

